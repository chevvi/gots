package ts

import (
	"reflect"
	"testing"
)

var PMTPayload = []byte{
	0x00, 0x02, 0xb0, 0x17, 0x00, 0x01, 0xc1, 0x00, 0x00, 0xe1, 0x00, 0xf0, 0x00, 0x1b, 0xe1, 0x00,
	0xf0, 0x00, 0x03, 0xe1, 0x01, 0xf0, 0x00, 0x4e, 0x59, 0x3d, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

var PATPayload = []byte{
	0x00, 0x00, 0xb0, 0x0d, 0x00, 0x01, 0xc1, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x2a, 0xb1, 0x04,
	0xb2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

func TestNewProgramMapTable(t *testing.T) {
	tests := []struct {
		name    string
		payload []byte
		want    *ProgramMapTable
	}{
		{
			name:    "Program map table",
			payload: PMTPayload,
			want: &ProgramMapTable{
				TableId:                2,
				SectionSyntaxIndicator: true,
				SectionLenght:          23,
				ProgramNumber:          1,
				VersionNumber:          0,
				CurrentNextIndicator:   true,
				SectionNumber:          0,
				LastSectionNumber:      0,
				PCRPID:                 256,
				ProgramInfoLength:      0,
				ElementaryStreams: []*ElementaryStream{
					&ElementaryStream{
						StreamType:    27,
						ElementaryPID: 256,
						ESInfoLength:  0,
						Data:          []byte{0x03, 0xe1, 0x01, 0xf0, 0x00},
					},
					&ElementaryStream{
						StreamType:    3,
						ElementaryPID: 257,
						ESInfoLength:  0,
						Data:          []byte{},
					},
				},
				CRC32: 1314471198,
			},
		},
	}
	for _, tt := range tests {
		if got := newProgramMapTable(tt.payload); !reflect.DeepEqual(got, tt.want) {
			t.Errorf("%q. newProgramMapTable() = %v, want %v", tt.name, got, tt.want)
		}
	}
}

func TestNewPogramAssociationTable(t *testing.T) {
	tests := []struct {
		name    string
		payload []byte
		want    *ProgramAssociationTable
	}{
		{
			name:    "Programm association table",
			payload: PATPayload,
			want: &ProgramAssociationTable{
				TableId:                0,
				SectionSyntaxIndicator: true,
				SectionLenght:          13,
				TransportStreamId:      1,
				VersionNumber:          0,
				CurrentNextIndicator:   true,
				SectionNumber:          0,
				LastSectionNumber:      0,
				Programs: []*Program{
					&Program{
						Number:        1,
						NetworkPID:    0,
						ProgramMapPID: 4096},
				},
				CRC32: 716244146,
			},
		},
	}
	for _, tt := range tests {
		if got := newPogramAssociationTable(tt.payload); !reflect.DeepEqual(got, tt.want) {
			t.Errorf("%q. newPogramAssociationTable() = %v, want %v", tt.name, got, tt.want)
		}
	}
}

func TestProgramMapTableHasElementaryStream(t *testing.T) {
	tests := []struct {
		name              string
		elementaryStreams []*ElementaryStream
		pid               uint16
		want              bool
	}{
		{
			name: "Contains elementary stream with PID",
			pid:  1234,
			elementaryStreams: []*ElementaryStream{
				&ElementaryStream{
					ElementaryPID: 1234,
				},
			},
			want: true,
		}, {
			name: "Doesn't contain elementary stream with PID",
			pid:  4321,
			elementaryStreams: []*ElementaryStream{
				&ElementaryStream{
					ElementaryPID: 1234,
				},
			},
			want: false,
		},
	}
	for _, tt := range tests {
		p := ProgramMapTable{
			ElementaryStreams: tt.elementaryStreams,
		}
		if got := p.HasElementaryStream(tt.pid); got != tt.want {
			t.Errorf("%q. ProgramMapTable.HasElementaryStream() = %v, want %v", tt.name, got, tt.want)
		}
	}
}
